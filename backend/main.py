# The api
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware

# Data validation and schema definition
from pydantic import BaseModel, Field, ConfigDict
from typing import List, Annotated, Optional, AsyncGenerator
from enum import IntEnum

# Custom modules
from database import engine, Base, AsyncSessionLocal
from models import TodoDB
from schemas import (
        TodoCreate,
        TodoUpdate,
        TodoResponse,
        Priority
)
from dependencies import get_db

from contextlib import asynccontextmanager
from typing import List, Optional
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

# Lifespan (startup and shutdown)
@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Code before 'yield' runs when the server starts.
    Code after 'yield' runs when the server stops.
    """
    print("Starting up... Checking Database...")
    
    # Create Tables
    # This creates tables if they don't exist
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    # Create Sample Data (if empty)
    async with AsyncSessionLocal() as session:
        # Check count of rows
        result = await session.execute(select(func.count()).select_from(TodoDB))
        if result.scalar() == 0:
            print("Database empty. Seeding sample data...")
            sample_todos = [
                TodoDB(name="Test task", description="Test description", priority=1),
            ]
            session.add_all(sample_todos)
            await session.commit()
    
    print("System Ready.")

    # The application runs while looking at this point
    yield
    
    print("Shutting down... Closing Database connection.")
    await engine.dispose()

# The app
app = FastAPI(
    title="Todo API",
    description="A FastAPI and Postgres async backend",
    lifespan=lifespan
)

# CORS configuration to allow frontend talk to the backend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # Should be changed in prod
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# A health endpoint
@app.get("/", tags=["Health"])
async def index():
    """Simple health check endpoint."""
    return {"status": "Backend is running ðŸš€"}

# Get all todos
@app.get("/todos", response_model=List[TodoResponse], tags=["Todos"])
async def get_todos(
        first_n: Optional[int] = None,
        db: AsyncSession = Depends(get_db)
):
    """Fetch all or first_n todos."""
    # Build the query
    # Select all todos ordered by ids
    query = select(TodoDB).order_by(TodoDB.id)

    if first_n:
        # Limit by n if the first_n is present
        query = query.limit(first_n)

    # Execute query (async)
    # await pauses here until DB responds
    result = await db.execute(query)

    # Extract Python objects from the result
    todos_db = result.scalars().all()

    # Conversion to Pydantic
    # I have set 'from_attributes=True' in TodoResponse, so if the field names match,
    # I can let Pydantic handle it
    # return [TodoResponse.model_validate(todo) for todo in todos_db]

    # Here is the manual mapping to show explicitly what happens
    return [
        TodoResponse(
            todo_id=todo.id,
            todo_name=todo.name,
            todo_description=todo.description,
            todo_priority=Priority(todo.priority) # Convert int to Enum
        ) for todo in todos_db
    ]

@app.get("/todos/{todo_id}", response_model=TodoResponse, tags=["Todos"])
async def get_todo(
        todo_id: int,
        db: AsyncSession = Depends(get_db)
):
    """Fetch a single specific todo by id."""
    # Query the db
    query = select(TodoDB).where(TodoDB.id == todo_id)
    result = await db.execute(query)
    # Returns None if not found
    todo = result.scalar_one_or_none()

    if not todo:
        raise HTTPException(status_code=404, detail="Todo not found")

    return TodoResponse(
        todo_id=todo.id,
        todo_name=todo.name,
        todo_description=todo.description,
        todo_priority=Priority(todo.priority)
    )

@app.post("/todos", response_model=TodoResponse, status_code=201, tags=["Todos"])
async def create_todo(
    todo_data: TodoCreate, 
    db: AsyncSession = Depends(get_db)
):
    """
    Create a new Todo.
    FastAPI automatically validates 'todo_data' against TodoCreate schema.
    """
    # Create the Database Model instance
    # Take the data from Pydantic (todo_data) and put it into SQLAlchemy (TodoDB)
    new_todo = TodoDB(
        name=todo_data.todo_name,
        description=todo_data.todo_description,
        priority=todo_data.todo_priority.value # Extract int value from Enum
    )
    
    # Add to session (staging area)
    db.add(new_todo)
    
    # Commit (save to DB)
    await db.commit()
    
    # Refresh (fetch the ID generated by the DB)
    await db.refresh(new_todo)
    
    # Return the result
    return TodoResponse(
        todo_id=new_todo.id,
        todo_name=new_todo.name,
        todo_description=new_todo.description,
        todo_priority=Priority(new_todo.priority)
    )

@app.put("/todos/{todo_id}", response_model=TodoResponse, tags=["Todos"])
async def update_todo(
    todo_id: int, 
    updates: TodoUpdate, 
    db: AsyncSession = Depends(get_db)
):
    """Update a todo. Only updates fields provided in the body."""
    # Fetch existing
    query = select(TodoDB).where(TodoDB.id == todo_id)
    result = await db.execute(query)
    todo_db = result.scalar_one_or_none()
    
    if not todo_db:
        raise HTTPException(status_code=404, detail="Todo not found")
    
    # Update fields if they are provided (not None)
    if updates.todo_name is not None:
        todo_db.name = updates.todo_name
    if updates.todo_description is not None:
        todo_db.description = updates.todo_description
    if updates.todo_priority is not None:
        todo_db.priority = updates.todo_priority.value
        
    # Save changes
    await db.commit()
    await db.refresh(todo_db)
    
    return TodoResponse(
        todo_id=todo_db.id,
        todo_name=todo_db.name,
        todo_description=todo_db.description,
        todo_priority=Priority(todo_db.priority)
    )

@app.delete("/todos/{todo_id}", response_model=TodoResponse, tags=["Todos"])
async def delete_todo(
    todo_id: int, 
    db: AsyncSession = Depends(get_db)
):
    """Delete a todo item."""
    # Fetch
    query = select(TodoDB).where(TodoDB.id == todo_id)
    result = await db.execute(query)
    todo_db = result.scalar_one_or_none()
    
    if not todo_db:
        raise HTTPException(status_code=404, detail="Todo not found")
    
    # Delete
    await db.delete(todo_db)
    await db.commit()
    
    # Return the deleted item (confirmation)
    return TodoResponse(
        todo_id=todo_db.id,
        todo_name=todo_db.name,
        todo_description=todo_db.description,
        todo_priority=Priority(todo_db.priority)
    )

